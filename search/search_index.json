{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"My personal notes on concepts worth mentioning.","title":"Home"},{"location":"architecture/practice/","text":"Components are only half the architecture When we think of systems architecture we usually picture a diagram with components and their relations, sometimes complemented with principles on how to structure them. Thise components are only half the architecture though. The other half consists of the people and their practices that make the components. They are equally important, but are almost never taken into account. This is like designing a car without considering the factory to actually make it. Practices should be centered around change and maintenance as systems do not run themselves. Systems require continual adaptation and maintenance to stay relevant. Like the car that needs a garage and maintenance schedule. Or maybe there is no garage in IT and it is the factory that needs to reproduce a fitting means of transportation each day. Be it a sedan, a station wagon or an SUV. All the more reason to pay attention to the architecture of the factory; to the architecture of our practices.","title":"Practice"},{"location":"architecture/practice/#components-are-only-half-the-architecture","text":"When we think of systems architecture we usually picture a diagram with components and their relations, sometimes complemented with principles on how to structure them. Thise components are only half the architecture though. The other half consists of the people and their practices that make the components. They are equally important, but are almost never taken into account. This is like designing a car without considering the factory to actually make it. Practices should be centered around change and maintenance as systems do not run themselves. Systems require continual adaptation and maintenance to stay relevant. Like the car that needs a garage and maintenance schedule. Or maybe there is no garage in IT and it is the factory that needs to reproduce a fitting means of transportation each day. Be it a sedan, a station wagon or an SUV. All the more reason to pay attention to the architecture of the factory; to the architecture of our practices.","title":"Components are only half the architecture"},{"location":"deep-work/rules/","text":"Deep Work Rules Rules for a rythmic deep work schedule. Plan sessions of 60 to 90 minutes in your agenda for doing deep work. Plan this weekly and refine daily at set times. Plan both subject and goal for each session in advance. Follow the optimal process given de subject during each session. At the start of the session close all communication and distractions. Open only your reference material and your output. Put on your headphone and start supporting music. Set your phone to quiet and put it face down on the table. Close Teams, Chats and Emails. Close Planners and Agendas. Close Windows that don't contribute to the subject. Close Notes. Open a new notepad if needed. At the end of the session open all communication channels and answer all simple and urgent requests. Stop the music. Check your phone for calls and messages. Open Teams, Chats and Emails. Evaluate the sessions ouput and process.","title":"Rules"},{"location":"deep-work/rules/#deep-work-rules","text":"Rules for a rythmic deep work schedule. Plan sessions of 60 to 90 minutes in your agenda for doing deep work. Plan this weekly and refine daily at set times. Plan both subject and goal for each session in advance. Follow the optimal process given de subject during each session. At the start of the session close all communication and distractions. Open only your reference material and your output. Put on your headphone and start supporting music. Set your phone to quiet and put it face down on the table. Close Teams, Chats and Emails. Close Planners and Agendas. Close Windows that don't contribute to the subject. Close Notes. Open a new notepad if needed. At the end of the session open all communication channels and answer all simple and urgent requests. Stop the music. Check your phone for calls and messages. Open Teams, Chats and Emails. Evaluate the sessions ouput and process.","title":"Deep Work Rules"},{"location":"deep-work/types/","text":"Deep Work Types Concept (architecture) Result: The definition and structuring of concepts that form the context of design. The main input of this type of work should be function. Design Result: Diagrams with supporting descriptions and assumptions that form the basis of future builds or clarify recent new builds. A design satisfies a complex set of goals (requirements). Design requires detailed knowledge of the build options, which comes from both documentation and build experience. It might also require the knowledge of previous designs like frameworks and standards if they are available. So design work should be preceded by the search for such designs. Build Result: Automated deployment of a service or component that satisfies a clear goal. Build work requires a clear goal and optionally a design when available. Note that Build and Design form an interplay. Build work is the transformation of documentation and experience into an automated deployment. Process Result: Work instructions that are simple enough to become habits.","title":"Types"},{"location":"deep-work/types/#deep-work-types","text":"","title":"Deep Work Types"},{"location":"deep-work/types/#concept-architecture","text":"Result: The definition and structuring of concepts that form the context of design. The main input of this type of work should be function.","title":"Concept (architecture)"},{"location":"deep-work/types/#design","text":"Result: Diagrams with supporting descriptions and assumptions that form the basis of future builds or clarify recent new builds. A design satisfies a complex set of goals (requirements). Design requires detailed knowledge of the build options, which comes from both documentation and build experience. It might also require the knowledge of previous designs like frameworks and standards if they are available. So design work should be preceded by the search for such designs.","title":"Design"},{"location":"deep-work/types/#build","text":"Result: Automated deployment of a service or component that satisfies a clear goal. Build work requires a clear goal and optionally a design when available. Note that Build and Design form an interplay. Build work is the transformation of documentation and experience into an automated deployment.","title":"Build"},{"location":"deep-work/types/#process","text":"Result: Work instructions that are simple enough to become habits.","title":"Process"},{"location":"tech/trust_tls/","text":"Trusting TLS TLS is one of the most used and least understood technologies. It secures connections, but how seems a mystery. This leaves us with statements like \"your credit card data will be stolen when you use self-signed certificates\". Nobody knows, but it sounds scary enough so it must be true. Or is it? TLS has two main functions. The first is encrypting data in transit. The second is providing trust on a public network. Encryption is the important one, but it is trust that we get worked up about. Encryption TLS encrypts TCP packets between client and server, using a key that only they know. This ensures that only the client and server can read the data they exchange. No intermediate can eavesdrop. The details are more complex, but this is the essence. Data is secured between the two parties. That is it. Fail-fast This encryption is guaranteed, because TLS is a fail-fast protocol. If the communication cannot be encrypted, it will not happen. This contrary to the browser messages saying your connection might not be safe. These messages only apply to trust and never to encryption. Trust TLS can also provide trust about the server that the client connects to. The server provides a certificate that holds the server address and is signed by a third party. The client can choose to trust the third party and its signed confirmation of the server address. Trust on the public network Trust is relevant on an untrusted network where client data can be intercepted by an intermediate system that poses as the intended server. The client can then be tricked into leaking sensitive information like password or credit card data. The trust function verifies that the server is the intended address. In an uncontrolled network it is useful to assure that data is sent to the intended recipient. In a controlled network though, this is useless at best. Here is why. Commercial CA's Trust, or more accurately \"TLS host verification\", works by first trusting the certificate of the Certificate Authority (CA) that signed the server certificate. This will let the client trust all the server certificates that the CA signs. Browsers and operating systems are preconfigured to trust a list of commercial CA's and server certificates are bought from these CA's. So because Chrome trusts a bundle of CA's and the site you are browsing has a certificate that is signed by one of those CA's, you don't have to worry about TLS. How different that is on a private network. Rolling your own Trusting a preconfigured commercial CA is no different from trusting a CA that you create yourself. It provides the same level of trust. The difference is that a certificate from your own CA is free, which makes it preferable over commercial CA's. The downside of this is that you have to configure each client to trust your CA. This configuration comes at a cost as well. That is when you should evaluate trust itself. Is there a change that a client can connect to an unverified server? If so, make the investment of configuring each client with your CA. If not, then you are better off with turning host verification off in your TLS connections. It delegates trust to your known network and leaves you with encryption. No more, no less. But my browser says When you decide that servers are known and that host verfication has no added value in your particular context, there is still your browser that screams bloody murder. That is because TLS host verfication was designed for the internet with non-technical users in mind. Just click OK and know that your connection is encrypted and safe.","title":"Trusting TLS"},{"location":"tech/trust_tls/#trusting-tls","text":"TLS is one of the most used and least understood technologies. It secures connections, but how seems a mystery. This leaves us with statements like \"your credit card data will be stolen when you use self-signed certificates\". Nobody knows, but it sounds scary enough so it must be true. Or is it? TLS has two main functions. The first is encrypting data in transit. The second is providing trust on a public network. Encryption is the important one, but it is trust that we get worked up about.","title":"Trusting TLS"},{"location":"tech/trust_tls/#encryption","text":"TLS encrypts TCP packets between client and server, using a key that only they know. This ensures that only the client and server can read the data they exchange. No intermediate can eavesdrop. The details are more complex, but this is the essence. Data is secured between the two parties. That is it.","title":"Encryption"},{"location":"tech/trust_tls/#fail-fast","text":"This encryption is guaranteed, because TLS is a fail-fast protocol. If the communication cannot be encrypted, it will not happen. This contrary to the browser messages saying your connection might not be safe. These messages only apply to trust and never to encryption.","title":"Fail-fast"},{"location":"tech/trust_tls/#trust","text":"TLS can also provide trust about the server that the client connects to. The server provides a certificate that holds the server address and is signed by a third party. The client can choose to trust the third party and its signed confirmation of the server address.","title":"Trust"},{"location":"tech/trust_tls/#trust-on-the-public-network","text":"Trust is relevant on an untrusted network where client data can be intercepted by an intermediate system that poses as the intended server. The client can then be tricked into leaking sensitive information like password or credit card data. The trust function verifies that the server is the intended address. In an uncontrolled network it is useful to assure that data is sent to the intended recipient. In a controlled network though, this is useless at best. Here is why.","title":"Trust on the public network"},{"location":"tech/trust_tls/#commercial-cas","text":"Trust, or more accurately \"TLS host verification\", works by first trusting the certificate of the Certificate Authority (CA) that signed the server certificate. This will let the client trust all the server certificates that the CA signs. Browsers and operating systems are preconfigured to trust a list of commercial CA's and server certificates are bought from these CA's. So because Chrome trusts a bundle of CA's and the site you are browsing has a certificate that is signed by one of those CA's, you don't have to worry about TLS. How different that is on a private network.","title":"Commercial CA's"},{"location":"tech/trust_tls/#rolling-your-own","text":"Trusting a preconfigured commercial CA is no different from trusting a CA that you create yourself. It provides the same level of trust. The difference is that a certificate from your own CA is free, which makes it preferable over commercial CA's. The downside of this is that you have to configure each client to trust your CA. This configuration comes at a cost as well. That is when you should evaluate trust itself. Is there a change that a client can connect to an unverified server? If so, make the investment of configuring each client with your CA. If not, then you are better off with turning host verification off in your TLS connections. It delegates trust to your known network and leaves you with encryption. No more, no less.","title":"Rolling your own"},{"location":"tech/trust_tls/#but-my-browser-says","text":"When you decide that servers are known and that host verfication has no added value in your particular context, there is still your browser that screams bloody murder. That is because TLS host verfication was designed for the internet with non-technical users in mind. Just click OK and know that your connection is encrypted and safe.","title":"But my browser says"}]}